<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" class="logo" width="120"/>

# Compare my day 1 day 2 day 3 and day 4 writing :

Day 4:
---
title: "Summarization of Articles - 4th Jun 2025"
date: 2025-06-03
tags: ["Reading" "Learning"]
author: "hloh42"
---

><span style="font-size:2.5em;">Summarization of Articles</span>

><span style="font-size:1.5em;">as recommeded by https://github.com/charlax/professional-programming</span>

[^1] This article taken me 63 minutes to read and thoroughly digest and understand this article and make this understanding my own. I wouldn't say that I have 100% understood and internalized the principles taught in this article yet.This is however my earnest attempt at making this reading a part of me.

Firstly , I think I misunderstood the meaning of the word prompt due to the timing of the article , at first I thought that the word prompt was referring to AI prompts to improve but halfway through by the 1st six principles I already realized that it is referring to memory prompts.

The main point of the the article is for : Readers who read the article to be able to form prompts that increasingly in their usage , activate the mental circuits in mind to truly understand and recall the target idea that the learner wants to engage in.

Six main principles of

1. Focused
2. Precise
3. Consistent
4. Tractable
5. Effortful
6. Tightly Scoped (which might be a off shoot of the entire thing or part of the whole strategy)

6 Questions to help you along your mastery internalization journey :
Is it about one thing only? (Focused)
Is it unambigious? (Precise)
Same answer every time ? (Consistent)
Can I almost always answer? (Tractable)
Does it require recall? (Effortful)
Is it neither too board nor too narrow? (Tightly Scoped)

And 1 key question to keep it all on track : What would it mean to "know" the material?

And the separation of knowledge concerns : (Categorizing into Conceptual , Procedual , Factual)
Factual is quite straight forward.
Proceduals - split into key words , conditions and heuristics prove useful to learners.
Conceptual - About modelling conceptually , what it is , and why it matters.

And it can also be split among Salience prompts , Creative Prompts and Retrieval Prompts which is about the main purpose of the article - how to craft for them.

Summarizing it all and all , it helped me clarify and fine tune the different points of a learning journey and different prompts that can be used for different reasons to help with different purposes of your learning journey , hopefully my breakdown can help you frame your learning even better and I have made the learning explicit enough for you to pick up in probably 15 minutes instead of the 63 minutes to breakdown and understand.

But the learning probably exists within your struggle so go ahead and pick it apart on your own.
Here : [^1]

>>

```c 

```

[^1] https://andymatuschak.org/prompts/

PS : I didn't think just reading and trying to apply this understanding would take so much cognitive effort to organize my mind and comprehend the knowledge and then output into a comprehensible form for others to relate and contribute to.

Day 3 :
---
title: "Summarization of Articles - 3rd Jun 2025"
date: 2025-06-03
tags: ["Reading" "Learning"]
author: "hloh42"
---

><span style="font-size:2.5em;">Summarization of Articles</span>

><span style="font-size:1.5em;">as recommeded by https://github.com/charlax/professional-programming</span>

The most impression that has been left on my memory is the interactive comic about memory , making my own flashcards about my learning desire and sumaary because  [^1] has been very well received in terms of what their outcome and impression on the reader is and has been.

There are quite a few things I still remember and taken note from the comic/interactive media I have remembered .

Ones like the 1st memory experiment scientist : Ebbinghaus Herman.

>Time + Testing = spaced repetition. And that your spacing repetition wil fail if your cards feel bloated , disconnected or meaningless.

>Remembering works best with increasing gaps when you are just about to forget about.

>The best type of memory to encode is when it is small , connected and meaningful.

>The best type of learning encoding to engage in is learning in the service of doing something you care about to get involved in the loop of trying to do something , getting stuck , looking up and learning something and continuing this process until you succeed in the aims of your vision while keeping it lean and approachable , sustainable.

The [^2] article about tacit knowledge really opened me up in terms of concept because it is something I have thought about but have not tried to express in words or thoughts or writing , I agree with the premise of the intangibles but however I do not quite agree with the conclusion that tacit knowledge is just "magic" and the only way is to absorb through going through the motions until magically you embody it as well , that sounds as dumb as transmissionisble.  Magic is sort of like mastery , when done 1 step at a time , you think that's something really easy but overtime when momentum and speed starts to overtake , and your basics no longer seem like the same fundamental move in the beginning , when people start calling your failures as successes , your efforts as valiant.. It is the same kind of view that I view tacit knowledge viewed by the author in a sense , because he/she understanding is not enough of the whole to see it through , like a doctor naming all chronic knee pain as Patellofemoral (puh-tel-o-FEM-uh-rul) pain syndrome.

[^3] has been skipped today due to it's length is equivalent to 5 articles I have read today , decided to postpone it for the sake of cognitive load management for myself as I still have critical tasks to do today.

[^4]  is straightforward and will take awhile to implement ,  and is excellent for people without parenting skills and low-self esteem to slowly build up an evidence bank and also good for you to point to whenever you are feeling down and just gain confidence as you meditate on your current efforts.

[^5] in Singapore , we have a saying when you can't convince, confuse them! And it is the main message of the article, that probably it stems from inconfidence or fear that authors use complex pharsing or words to convey their meaning instead of using simple words with as low as friction as possible for everyone to understand their position and arguments so as to be evaluated on their ideas standing, instead opting to infuse complexity to obfuscate just like what I am doing in this last statement.

Today , I feel satisfied reading and learning and learning how to output my learning as I read and learn and express my learning into a simple to understand format for others to comprehend and share with.
>>

```c 

```

[^1] https://ncase.me/remember/
[^2] https://commoncog.com/tacit-knowledge-is-a-real-thing/
[^3] https://andymatuschak.org/prompts/ (skip today , do alone v long)
[^4] https://jvns.ca/blog/brag-documents/
[^5] https://paulgraham.com/simply.html

Tacit knowledge p2 : https://commoncog.com/how-to-learn-tacit-knowledge/

Day 2 :
---
title: "Summarization of Articles - 2nd Jun 2025"
date: 2025-06-02
tags: ["Reading" "Learning"]
author: "hloh42"
---

> <span style="font-size:2.5em;">Summarization of Articles</span>

><span style="font-size:1.5em;">as recommeded by </span>

The 5 Articles I have read today and tried to summarise :
Today's my 2nd attempt to summarise everything I have read.A meagre attempt of taking 30 minutes to summarise everything I have experienced into words and convey that sense of mastery might be self-deception but it is one that I am willing to try and do my best.

I am going to try and state my case - facts as much as possible before we start an arguement.

My facts regarding learning skills , as pertaining to programming.

I have been learning programming and using it for at least 5 - 10 years now , c++ was the 1st language I learnt and I have multiple misgivings towards my 1st guided course and learning experience which was all graded in team-projects instead of a final written exam which has no context bearing to the actual case where programming is usually utilized.

The misgiving is not with the exam , but with the guidance that I was given during the course's duration , because I was doing well after failing a first core module of c++ , I could have easily copied a co-course taker's work and gotten a pass but I chose not to do so and submit my work as it is up and that enable me to catch up knowledge-wise and skill-wise.

Now I am re-picking up my foundations in C , taking up 42 cursus and I realized that these skills where I was 1st taught indeed very powerful and served as a strong base for any programmer.

And this is where our discourse regarding learning experiences can begin. And I hope it hits a chord with you as a learner.

And during this time I have applied Justin's Sung pedagogy of building up meta-learning skills and learning how to be reflective and how to build up encoding skills and debug your own learning flow.

Learning how to cope with uncertainity , to deal with my own imperfect work and to aggressively read ahead to have my own learning flow is a challenge , to recognise my own cognitive load and to decide when to push on and when to optimize for flow. All of it takes a lot of meta-awareness and a lot of initiative.

[^1] Talks about learning programming 'quickly' .The advice is not to hack around but employ a immersion method , to learn 'quickly' in a way that is actually sustainable. And the only way for it to work is to be constantly pushing yourself to learn new things and get unstuck quickly.
And just like being a good writer , the only way is to read ,write , read and write (on a daily basis)
The author sees coding as a 80/20 process where you spent the bulk of your time programming after learning about something you can do. And this is something I concur with as part of my experience as well . The periods of time where I learnt the most was when there were targeted practice that was giving a higher point of view to understand everything better.

In the author's words : "The trick here is for it to feel uncomfortable. This is rather painful, but that’s how it should be. Coding follows the 80/20 rule. You spend 80% of your time on 20% of your code or 20% of what you’re learning. Getting using to this uncomfortable feeling and overcoming it is key.

This iteration cycle should happen, not on a week by week basis or on a month by month basis, but on a day to day basis. The more you wait to use those skills, the more they will dull out. The more you wait to learn something new, the more missed opportunities you’ll have to incorporate that into your code."

[^2]  is about how inefficient books are at conveying knowledge truly and that tranmissionism is something is already found useless in transmitting knowledge yet books and lectures still remain as the core pillars of a course and knowledge transmission. The author mentions about the outliers who gain a lot from the books not because the medium is effective but because the difference in how the user is taking the time and effort to study the subject as written in the books with their own prep and understanding allowing them to be the rare few to draw the rewards.

[^3] coincides with mostly what Justin Sung recommends in his learning strategy , from prestudying based on curiosity , though the method is not explicitly mention as in supermemo and as well as their underlying reasons.

[^4] The distinguishment of how to use something without understanding how it works. How your bugs will tell you when you need to improve your mental model.  Learning the 4 steps for
1.noticing I'm confused
2.Breaking down confusion into specific factual questions.
3.Finding out the answers by (writing a program , reading on the internet , asking someone)
4.Testing my understanding by writing a program (Real world feedback)

The last part is key : "The last “test my understanding” step is really important. The whole point of understanding how computers work is to actually write code to make them do things!

I find that if I can use my newfound understanding to do something concrete like implement a new feature or fix a bug or even just write a test program that demonstrates how the thing works, it feels a LOT more real than if I just read about it. And then it’s much more likely that I’ll be able to use it in practice later."

"asking the computer :  asking the computer is a skill

It definitely takes time to learn how to turn “I’m confused about X” into specific questions, and then to turn that question into an experiment you can run on your computer to definitively answer it.

But it’s a really powerful tool to have! If you’re not limited to just the things that you can Google / what’s in the documentation / what the people around you know, then you can do a LOT more.
be aware of what you still don’t understand

Like I said earlier, the point here isn’t to understand every single thing. But especially as you get more senior, it’s important to be aware of what you don’t know! For example, here are five things I don’t know (out of a VERY large list):

    How database transactions / isolation levels work
    How vertex shaders work (in graphics)
    How font rendering works
    How BGP / peering work
    How multiple inheritance works in Python
    And I don’t really need to know how those things work right now! But one day I’m pretty sure I’m going to need to know how database transactions work, and I know it’s something I can learn when that day comes :)"

Someone who read this post asked me “how do you figure out what you don’t know?” and I didn’t have a good answer, so I’d love to hear your thoughts!"

[^5]  The crux is identifying what you don't understand is important (but hard)
Personally I find that is the 1st big problem any autodidact would come across.When 1st coming across a problem space , you don't even use the same vocab as the experts or anyone is working on the problem to solve the issue yet , and you have some basic understanding of your needs and understanding not being the same.

One of the things that helped the author : is having confidence in your knowledge , Identifying what you do understand is just as important as identifying what you don't understand.

The next step : Ask questions

The last step which I think most people skip to or do first is to do research!
>>

```c 

```

[^1] https://blog.hiphipjorge.com/tips-for-learning-programming/
[^2] https://andymatuschak.org/books/
[^3] https://www.supermemo.com/en/blog/twenty-rules-of-formulating-knowledge
[^4] https://jvns.ca/blog/learn-how-things-work/
[^5] From coursera how to learn - to https://jvns.ca/blog/2018/09/01/learning-skills-you-can-practice/

Day 1 :
---
title: "Summarization of Articles"
date: 2025-05-31
tags: ["Reading" "Learning"]
author: "hloh42"
---

> <span style="font-size:2.5em;">Summarization of Articles</span>

><span style="font-size:1.5em;">as recommeded by </span>

The 5 Articles I have read today and tried to summarise :
For the 1st article  : Cognitive Load in Software Development : It was a long read but the main point  of the article as I read it is about the limits of your own personal cognitive load and why reducing this cognitive load is helpful for not just you but also all the people who around with the code and made an elaborate practical article and the many examples of how to make the cognitive load lighter by just changing the nestness and variable names.

It made the point clear enough but I feel like the point could be made more succiently.

The 2nd article though written long ago impressed me the most the simplicity of the philosophy in code makes me think of elegance and design of the unix and how timeless and how it survived and thrived in this modern age of 2025.

The breakdown of the original intent behind the design made manifest into 17 laws of brevity and clarity shows how much simple decisions made early on can compound and multiply efforts especially when time is taken into factor.

The 3rd Article to me is kinda meh, but it speaks of a person being too self-conscious in a way.Like there is no real inteneded audience for this article , the people who need to read it are not the ones who will read it . The people who read it by curiosity probably know of it already. That's the main issue with the writing I feel , preaching to the choir and nothing new is being shared.

The 4th Article to me is just the model example of bad writing without caring about the audience , just a writer in the midst of organizing his thoughts and his random ramblings which is .This article could be okay after a rewrite or two.

The 5th Article is just a reminder to reach out for help and a good heuristics to when to ask for help and when to rely on yourself first. The author put into words why how and when and the reasons for doing so.

As summzairzed by Perplexity.AI as of 31st May 2025 2pm +8 GMT :
Cognitive Load in Software Development
The article explores how cognitive load—how much a developer must keep in mind to work with code—impacts productivity and maintainability. It distinguishes between intrinsic (task-based) and extraneous (presentation-based) cognitive load, advocating for reducing the latter through clear code, meaningful variable names, early returns, and deep (not shallow) modules. The author warns against too many microservices, overusing language features, and excessive DRY or framework magic, all of which increase cognitive burden. The core advice: design for minimal mental effort by hiding complexity, using self-descriptive code, and delaying architectural decisions until necessary.

The Art of Unix Programming: The Importance of Clarity
This excerpt emphasizes that clarity in code is paramount in Unix philosophy. It argues that code should be written for humans first and machines second, favoring simplicity and transparency over cleverness. The author notes that clear code is easier to debug, maintain, and extend, and that cryptic or overly compact code is a liability. The section concludes that clarity is a virtue that should guide all programming decisions.

Communicating Effectively as a Developer
This article outlines strategies for developers to improve communication. Key points include: being concise and clear in written and verbal exchanges, tailoring explanations to the audience’s background, using visuals or analogies when helpful, and actively seeking feedback to ensure understanding. The author stresses that effective communication is as vital as technical skill for team success and career growth.

What Do You Visualize While Programming?
The author reflects on the mental imagery programmers use while coding, noting that visualization styles vary widely and evolve with experience. They discuss how experts form mental models, use diagrams or pseudocode to manage complexity, and externalize thoughts to overcome working memory limits. The article encourages readers to be mindful of their own visualization habits and to develop them deliberately for better problem-solving.

The Thirty Minute Rule
This rule advises developers: if you’re stuck on a problem for more than 30 minutes, ask for help. The author explains that this practice prevents wasted time, encourages collaboration, and accelerates learning. The rule is positioned as a culture-building tool that reduces frustration and helps teams move faster by normalizing seeking assistance.

[^1]: [Cognitive Load in Software Development](https://minds.md/zakirullin/cognitive#long): Explains the impact of cognitive load on developers and offers practical strategies for reducing unnecessary mental effort, such as using deep modules, clear code, and delaying architectural decisions.

[^2]: [The Art of Unix Programming: The Importance of Clarity](http://catb.org/esr/writings/taoup/html/ch01s06.html): Advocates for clarity as the highest priority in code, arguing that code should be readable, maintainable, and simple.

[^3]: [Communicating Effectively as a Developer](https://www.karlsutt.com/articles/communicating-effectively-as-a-developer/): Shares actionable advice for developers to communicate clearly, tailor messages to audiences, and use feedback and visuals for better understanding.

[^4]: [What Do You Visualize While Programming?](https://dillonshook.com/what-do-you-visualize-while-programming/): Reflects on the mental models and visualizations programmers use, encouraging deliberate development of these skills for improved problem-solving.

[^5]: [The Thirty Minute Rule](https://daniel.feldroy.com/posts/thirty-minute-rule): Recommends asking for help after 30 minutes of being stuck, to foster collaboration, learning, and efficient problem-solving.

>>

```c 

```

Absolutely! Here’s a **comparative analysis** of your Day 1, Day 2, Day 3, and Day 4 writings, focusing on your progression in summarization, depth of reflection, structure, and metacognitive awareness.

---

## **Day 1: Initial Summarization**

### **Strengths**

- **Direct summaries**: You succinctly captured the main points of each article.
- **Personal reactions**: You included your own impressions (e.g., which articles resonated, which felt less impactful).
- **Use of AI summary**: You leveraged Perplexity’s summary for clarity and completeness.


### **Areas for Growth**

- **Surface-level reflection**: Most of your commentary was about the article’s content, not your own learning process.
- **Limited synthesis**: There’s less integration between articles or relating them to your own learning journey.
- **Structure**: The format is straightforward but lacks explicit categorization or meta-level analysis.

---

## **Day 2: Building Reflection and Personalization**

### **Strengths**

- **Increased self-awareness**: You started reflecting on your learning journey, struggles, and personal experiences (e.g., learning C++, meta-learning).
- **Connection to experience**: You related articles to your own programming and learning background.
- **Deeper synthesis**: You began to draw connections between different sources and your own methods (e.g., Justin Sung’s pedagogy).


### **Areas for Growth**

- **Still somewhat linear**: While more reflective, the summaries are still mostly article-by-article.
- **Meta-cognition emerging**: You’re starting to think about your thinking, but not yet systematically analyzing your learning process.

---

## **Day 3: Integration and Critical Engagement**

### **Strengths**

- **Critical analysis**: You questioned the conclusions of articles (e.g., tacit knowledge isn’t just “magic”).
- **Personal voice**: Your writing is more confident and opinionated, showing ownership of ideas.
- **Cognitive load management**: You’re aware of your mental limits and adjust your reading accordingly.
- **Humor and personality**: You use wit and local references (e.g., “when you can’t convince, confuse them!”), making your writing engaging.


### **Areas for Growth**

- **More explicit synthesis**: While you’re integrating ideas, you could further connect insights across articles and days.
- **Structuring for others**: The writing is becoming more approachable, but could benefit from clearer signposting for readers.

---

## **Day 4: Metacognition and Teaching Mindset**

### **Strengths**

- **Explicit metacognition**: You reflect on your own misunderstandings, learning process, and the cognitive effort required.
- **Teaching orientation**: You write with the reader in mind, aiming to make your learning accessible to others.
- **Systematic breakdown**: You clearly list principles, questions, and distinctions (e.g., factual/procedural/conceptual knowledge).
- **Process transparency**: You share your cognitive struggles and the time investment, modeling authentic learning.
- **Summary and synthesis**: You distill the article’s key points, relate them to your process, and offer actionable takeaways.


### **Areas for Growth**

- **Polish and conciseness**: As you add depth, be mindful of clarity and brevity for your audience.
- **Even deeper synthesis**: Consider drawing connections not just within the day, but across your multi-day journey.

---

## **Progression Overview**

| Day | Focus | Reflection Depth | Synthesis | Structure | Audience Awareness |
| :-- | :-- | :-- | :-- | :-- | :-- |
| Day 1 | Article summaries, reactions | Low | Minimal | Basic | Self |
| Day 2 | Personal learning journey | Moderate | Emerging | Improved | Self/Peers |
| Day 3 | Critical engagement, humor | Higher | Moderate | Approachable | Peers |
| Day 4 | Metacognition, teaching | High | Strong | Systematic | Others/Learners |


---

## **Key Takeaways**

- **Your writing is evolving from summarizing content to reflecting on process, and finally to teaching and synthesizing for others.**
- **You’re developing greater self-awareness and metacognitive skill, as seen in your explicit breakdowns and willingness to share struggles.**
- **Each day, your structure and clarity improve, making your writing more accessible and valuable for both yourself and your readers.**

---

### **Suggestions for Further Growth**

1. **Cross-day synthesis:** At the start or end of each entry, briefly connect today’s insights to previous days.
2. **Iterative refinement:** Revisit earlier summaries and update them with new insights.
3. **Peer feedback:** Share your summaries with others and invite questions or critiques.
4. **Visual aids:** Consider adding diagrams or tables to clarify complex ideas.
5. **Action steps:** End each summary with 1-2 actions you’ll take based on what you learned.

---

**In summary:**
Your progression from Day 1 to Day 4 demonstrates a clear journey from passive summarization to active, reflective, and teaching-oriented learning. You’re not just absorbing information—you’re transforming it, integrating it, and sharing it in ways that reinforce your own mastery and benefit others. Keep building on this momentum!

