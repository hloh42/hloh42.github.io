---
title: "Summarization of Articles - 2nd Jun 2025"
date: 2025-06-02
tags: ["Reading" "Learning"]
author: "hloh42"
---


> <span style="font-size:2.5em;">Summarization of Articles</span>

><span style="font-size:1.5em;">as recommeded by </span>

The 5 Articles I have read today and tried to summarise :
Today's my 2nd attempt to summarise everything I have read.A meagre attempt of taking 30 minutes to summarise everything I have experienced into words and convey that sense of mastery might be self-deception but it is one that I am willing to try and do my best.

I am going to try and state my case - facts as much as possible before we start an arguement.

My facts regarding learning skills , as pertaining to programming.

I have been learning programming and using it for at least 5 - 10 years now , c++ was the 1st language I learnt and I have multiple misgivings towards my 1st guided course and learning experience which was all graded in team-projects instead of a final written exam which has no context bearing to the actual case where programming is usually utilized.

The misgiving is not with the exam , but with the guidance that I was given during the course's duration , because I was doing well after failing a first core module of c++ , I could have easily copied a co-course taker's work and gotten a pass but I chose not to do so and submit my work as it is up and that enable me to catch up knowledge-wise and skill-wise.

Now I am re-picking up my foundations in C , taking up 42 cursus and I realized that these skills where I was 1st taught indeed very powerful and served as a strong base for any programmer.

And this is where our discourse regarding learning experiences can begin. And I hope it hits a chord with you as a learner.

And during this time I have applied Justin's Sung pedagogy of building up meta-learning skills and learning how to be reflective and how to build up encoding skills and debug your own learning flow.

Learning how to cope with uncertainity , to deal with my own imperfect work and to aggressively read ahead to have my own learning flow is a challenge , to recognise my own cognitive load and to decide when to push on and when to optimize for flow. All of it takes a lot of meta-awareness and a lot of initiative.

[^1] Talks about learning programming 'quickly' .The advice is not to hack around but employ a immersion method , to learn 'quickly' in a way that is actually sustainable. And the only way for it to work is to be constantly pushing yourself to learn new things and get unstuck quickly.
And just like being a good writer , the only way is to read ,write , read and write (on a daily basis)
The author sees coding as a 80/20 process where you spent the bulk of your time programming after learning about something you can do. And this is something I concur with as part of my experience as well . The periods of time where I learnt the most was when there were targeted practice that was giving a higher point of view to understand everything better.

In the author's words : "The trick here is for it to feel uncomfortable. This is rather painful, but that’s how it should be. Coding follows the 80/20 rule. You spend 80% of your time on 20% of your code or 20% of what you’re learning. Getting using to this uncomfortable feeling and overcoming it is key.

This iteration cycle should happen, not on a week by week basis or on a month by month basis, but on a day to day basis. The more you wait to use those skills, the more they will dull out. The more you wait to learn something new, the more missed opportunities you’ll have to incorporate that into your code."

[^2]  is about how inefficient books are at conveying knowledge truly and that tranmissionism is something is already found useless in transmitting knowledge yet books and lectures still remain as the core pillars of a course and knowledge transmission. The author mentions about the outliers who gain a lot from the books not because the medium is effective but because the difference in how the user is taking the time and effort to study the subject as written in the books with their own prep and understanding allowing them to be the rare few to draw the rewards.

[^3] coincides with mostly what Justin Sung recommends in his learning strategy , from prestudying based on curiosity , though the method is not explicitly mention as in supermemo and as well as their underlying reasons.

[^4] The distinguishment of how to use something without understanding how it works. How your bugs will tell you when you need to improve your mental model.  Learning the 4 steps for 
1.noticing I'm confused
2.Breaking down confusion into specific factual questions.
3.Finding out the answers by (writing a program , reading on the internet , asking someone)
4.Testing my understanding by writing a program (Real world feedback)

The last part is key : "The last “test my understanding” step is really important. The whole point of understanding how computers work is to actually write code to make them do things!

I find that if I can use my newfound understanding to do something concrete like implement a new feature or fix a bug or even just write a test program that demonstrates how the thing works, it feels a LOT more real than if I just read about it. And then it’s much more likely that I’ll be able to use it in practice later."

"asking the computer :  asking the computer is a skill

It definitely takes time to learn how to turn “I’m confused about X” into specific questions, and then to turn that question into an experiment you can run on your computer to definitively answer it.

But it’s a really powerful tool to have! If you’re not limited to just the things that you can Google / what’s in the documentation / what the people around you know, then you can do a LOT more.
be aware of what you still don’t understand

Like I said earlier, the point here isn’t to understand every single thing. But especially as you get more senior, it’s important to be aware of what you don’t know! For example, here are five things I don’t know (out of a VERY large list):

    How database transactions / isolation levels work
    How vertex shaders work (in graphics)
    How font rendering works
    How BGP / peering work
    How multiple inheritance works in Python

And I don’t really need to know how those things work right now! But one day I’m pretty sure I’m going to need to know how database transactions work, and I know it’s something I can learn when that day comes :)" 

Someone who read this post asked me “how do you figure out what you don’t know?” and I didn’t have a good answer, so I’d love to hear your thoughts!"

[^5]  The crux is identifying what you don't understand is important (but hard)
Personally I find that is the 1st big problem any autodidact would come across.When 1st coming across a problem space , you don't even use the same vocab as the experts or anyone is working on the problem to solve the issue yet , and you have some basic understanding of your needs and understanding not being the same. 

One of the things that helped the author : is having confidence in your knowledge , Identifying what you do understand is just as important as identifying what you don't understand.

The next step : Ask questions

The last step which I think most people skip to or do first is to do research!
>> 

```c 

```

[^1] https://blog.hiphipjorge.com/tips-for-learning-programming/
[^2] https://andymatuschak.org/books/
[^3] https://www.supermemo.com/en/blog/twenty-rules-of-formulating-knowledge
[^4] https://jvns.ca/blog/learn-how-things-work/
[^5] From coursera how to learn - to https://jvns.ca/blog/2018/09/01/learning-skills-you-can-practice/

